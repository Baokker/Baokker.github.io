---
title: 数据结构与算法的笔记简单整理（持续更新
author: Baokker
avatar: 'https://cdn.jsdelivr.net/gh/Baokker/cdn_for_blog/img/custom/avatar.jpg'
authorLink: Baokker.github.io
categories: 技术
comments: true
date: 2021-09-226 13:55:21
tags:
 - 技术
keywords: 技术 算法
description: 好难 我都不懂 呜呜
photos: https://cdn.jsdelivr.net/gh/Baokker/cdn_for_blog/blog_imgs/tiger-2535888_1920.jpg
---

# 开学学习内容

## 数据结构

* [快速转置算法][https://blog.csdn.net/qq845579063/article/details/51354847]
* [KMP算法详解][https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html]
* BM算法
* **带头结点**的链表（dummyHead？）
* 双向循环链表

## LeetCode

- 双指针
- 链表→递归&迭代
- dummyHead
- 循环不变量的确定
- 不变量（例如区间，在写之前就应当确定是[a,b]或者[a,b)）

## 编写中遇到的c++语法问题

- ```cpp
  template <class Type> // == template <typename Type>   
  ```

- 关于<<和>>的运算符重载：

  - 一般的运算符重载可以在类内直接解决

  - 但是这两个运算符 为保证和正常使用cin和cout的习惯 需要将参数列表设为(istream &input,class Classname)（同时返回也要右值引用

  - 但是类内声明时 **会默认在参数列表首位加上this指针**

  - 因此 这类函数只能在外部声明（假如数据全部可访问） 或者只能在类内作为友元函数来访问 因为**友元函数不会加上this指针**

  - 较为正确的方法：

    ```cpp
    class Candidate:
    {
        private:
        //..
        public:
        //..
        friend ostream& operator<<(ostream& output, const Candidate candidate) // 重载输出函数
    }
    ```

    

- STL的stack的pop()函数不会返回弹出数据 如需使用请结合pop()

- c++的文件读入（istream）输出（ostream）一段文字

  最后我先用了cin.get()将输入的文字输出到ostream 然后读取时用getline将istream内数据读取

- 经过一番探索后我发现
  将带模板的类的声明和定义放在.h和.cpp中 另外加上main.cpp是不对的行为
  因为template function will be compiled only when it is used 
  而main中只包含了头文件而不包含.cpp 会导致其"invisible to the implementation"\
  所以 要么都写在头文件中 要么就在h末尾加上#include"...cpp"
  
- ```cpp
  if (a = 1) cout << "..";
  // equal to
  // 1. a=1;
  // if (a) ..
  // cause the = operator will return this integer
  ```

- ```cpp
  int a = 3 << 4; // a = 3 * (2 ^ 4) = 48 左移运算符
  int b = 8 >> 1; // b = 8 / (2 ^ 1) = 4  右移运算符
  ```

- vector的几种赋值or拷贝方法：

  ```cpp
  vector<int> example={1,2,3,4};
  vector<int> target1(example);
  vector<int> target2(example.begin(),example.begin()+2);
  vector<int> target3;
  target3.assign(2,2);
  target3.assign(example.begin(),example.begin()+2); //[a,b)
  vector<int> target4;
  target4.swap(example);//example={}
  ```

  



# 开学之前

## AES算法

- 对称加密算法（advanced encryption standard）（即可逆）

- 概念

  - 密钥

    - AES128/192/256

  - 填充

    - 在存在不满的情况下 以一些规则来填充未满部分

  - 模式

    明文加密为密文

- 加密过程

  - 初始轮

    加轮密钥

  - 普通轮

    字节代替

    行移位

    列混淆

    加轮密钥

  - 最终轮

    字节代替

    行移位

    加轮密钥



## 快速排序

- 分治法
- pivot的选择的几种方式
  - 选第一个
  - 随机数
- partition的分法
  - 挖坑法
  - 指针交换fa



## 优先队列

- 最大优先队列：最大的元素优先出队
- 最小优先队列：最小的元素优先出队
- 实现：堆排序



## 跳跃表

在链表中建立索引 乃至于索引的索引 来加快查找速度

插入：

- 新节点和各层索引节点逐一比较，确定原链表的插入位置。O（logN）
- 把索引插入到原链表。O（1）
- 利用抛硬币的随机方式，决定新节点是否提升为上一级索引。结果为“正”则提升并继续抛硬币，结果为“负”则停止。O（logN）
- 总体上，跳跃表插入操作的时间复杂度是O（logN），而这种数据结构所占空间是2N，既空间复杂度是 O（N）

删除：

- 自上而下，查找第一次出现节点的索引，并逐层找到每一层对应的节点。O（logN）
- 删除每一层查找到的节点，如果该层只剩下1个节点，删除整个一层（原链表除外）。O（logN）
- 总体上，跳跃表删除操作的时间复杂度是O（logN）。



## HashMap

* 默认初始长度为16 且每次扩容只能*2

* 均匀分布：位运算

  > **index = HashCode（Key） & （Length – 1）** 



## Chrome 脚本安装

1. 打开chrome扩展程序页 – chrome://extensions
2. 将刚才的自定义脚本保存为以user.js为后缀的 .js文件，例如test.user.js，拖入扩展程序页。
3. 重启浏览器。
4. 进入月饼抢购活动页面。此时脚本已自动执行。

[link](https://www.cxyxiaowu.com/4627.html)



## 空间复杂度

**S(n)=O(f(n))**

例如 递归的空间复杂度为n



## 归并排序

分而治之 先分为一个个小块（类似于二叉树一样） 再往上溯源 合并



## 快速排序



## 桶排序

伪代码（摘自Wikipedia

```text
function bucket-sort(array, n) is
  buckets ← new array of n empty lists
  for i = 0 to (length(array)-1) do
    insert array[i] into buckets[msbits(array[i], k)]
  for i = 0 to n - 1 do
    next-sort(buckets[i])
  return the concatenation of buckets[0], ..., buckets[n-1]
```



## Floyd 最短路算法



## 邻接表

数组＋单链表



## 判断单链表是否存在环

快慢法

一直走法

---

该图片由<a href="https://pixabay.com/zh/users/andibreit-2748383/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2535888">Andreas Breitling</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2535888">Pixabay</a>上发布